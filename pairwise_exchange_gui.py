"""
pairwise_exchange_gui.py

How to run:
 - Ensure you have Python 3 (standard library only).
 - Run: `python pairwise_exchange_gui.py`

This Tkinter app demonstrates the Pairwise Exchange Method for facility
layout design. It includes random problem generation, manual editing of the
flow matrix and layout, step-by-step execution (Next/Previous), Run to End
with a responsive UI, visualization of the layout, and export of logs.

Features:
 - n departments (3..12), default 8
 - grid layout computed to fit n (rows = ceil(sqrt(n)))
 - flows: random generator with seed, min/max/sparsity and symmetric toggle
 - distances: Manhattan (default) or Euclidean
 - algorithm: pairwise exchange choosing best improving swap by ΔC
 - displays both ΔC (efficient calc) and full-cost recomputation for validation
 - history logging and export (CSV + TXT)

Notes on cost computation and ΔC (short): see GUI Help -> "ΔC explanation"

Author: Generated by an assistant. Inline comments provided.
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import math
import random
import itertools
import csv
import io
import time

# ---------- Utility functions ----------

def ceil_sqrt(n):
    r = int(math.ceil(math.sqrt(n)))
    return r

def make_grid_positions(n):
    # rows = ceil(sqrt(n)); cols = ceil(n/rows)
    rows = ceil_sqrt(n)
    cols = int(math.ceil(n / rows))
    positions = []
    idx = 0
    for r in range(rows):
        for c in range(cols):
            if idx < n:
                positions.append((r, c))
            else:
                positions.append((r, c))
            idx += 1
    # we only need first n positions
    return positions[:rows * cols], rows, cols

def manhattan(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def euclidean(a, b):
    return math.hypot(a[0] - b[0], a[1] - b[1])

# ---------- Core algorithm functions ----------

def compute_distance_matrix(positions, metric='manhattan'):
    npos = len(positions)
    D = [[0.0] * npos for _ in range(npos)]
    for p in range(npos):
        for q in range(npos):
            if metric == 'manhattan':
                D[p][q] = manhattan(positions[p], positions[q])
            else:
                D[p][q] = euclidean(positions[p], positions[q])
    return D

def total_cost(F, D, layout):
    # Full double-sum as specified: sum_{i=1..n} sum_{j=1..n} F[i][j]*D[L(i),L(j)]
    n = len(F)
    cost = 0.0
    for i in range(n):
        for j in range(n):
            cost += F[i][j] * D[layout[i]][layout[j]]
    return cost

def delta_cost_for_swap(F, D, layout, a, b):
    # Efficient ΔC computation by summing only terms affected by swapping a and b.
    # layout: list mapping department -> position index
    n = len(F)
    pa = layout[a]
    pb = layout[b]
    delta = 0.0

    for k in range(n):
        if k == a or k == b:
            continue
        pk = layout[k]
        # contribution change when i==a or j==a
        delta += F[a][k] * (D[pb][pk] - D[pa][pk])
        delta += F[k][a] * (D[pk][pb] - D[pk][pa])
        # contribution change when i==b or j==b
        delta += F[b][k] * (D[pa][pk] - D[pb][pk])
        delta += F[k][b] * (D[pk][pa] - D[pk][pb])

    # terms where i and j are a or b
    delta += F[a][a] * (D[pb][pb] - D[pa][pa])
    delta += F[b][b] * (D[pa][pa] - D[pb][pb])

    # cross terms a<->b
    delta += F[a][b] * (D[pb][pa] - D[pa][pb])
    delta += F[b][a] * (D[pa][pb] - D[pb][pa])

    return delta

# ---------- GUI Application ----------

class PairwiseExchangeApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title('Pairwise Exchange Method - Teaching App')
        self.geometry('1200x780')

        # Model state
        self.n = 8
        self.names = [f'D{i+1}' for i in range(self.n)]
        self.positions, self.grid_rows, self.grid_cols = make_grid_positions(self.n)
        self.metric = 'manhattan'  # or 'euclidean'
        self.force_symmetric = True
        self.max_iterations = 1000
        self.show_all_swaps = True
        self.top_k = 10

        # default matrices
        self.F = [[0.0] * self.n for _ in range(self.n)]
        self.D = compute_distance_matrix(self.positions, self.metric)
        self.layout = list(range(self.n))  # department i -> position index

        # history of steps
        self.history = []  # list of dicts with iteration info
        self.history_index = -1

        # Running flag and after() id
        self.running = False
        self.run_after_id = None

        # Build UI
        self.create_widgets()

        # Load built-in demo
        self.load_example_8()

    # ---------- UI building ----------
    def create_widgets(self):
        control_frame = ttk.Frame(self)
        control_frame.pack(side='left', fill='y', padx=6, pady=6)

        # Problem size
        size_frame = ttk.LabelFrame(control_frame, text='Problem')
        size_frame.pack(fill='x', pady=4)
        ttk.Label(size_frame, text='n (3..12):').grid(row=0, column=0, sticky='w')
        self.n_var = tk.IntVar(value=self.n)
        n_spin = ttk.Spinbox(size_frame, from_=3, to=12, textvariable=self.n_var, width=5,
                             command=self.on_n_change)
        n_spin.grid(row=0, column=1, sticky='w')

        ttk.Label(size_frame, text='Metric:').grid(row=1, column=0, sticky='w')
        self.metric_var = tk.StringVar(value=self.metric)
        metric_combo = ttk.Combobox(size_frame, textvariable=self.metric_var,
                                    values=['manhattan', 'euclidean'], state='readonly', width=10)
        metric_combo.grid(row=1, column=1, sticky='w')
        metric_combo.bind('<<ComboboxSelected>>', lambda e: self.update_distance())

        self.sym_var = tk.BooleanVar(value=self.force_symmetric)
        ttk.Checkbutton(size_frame, text='Force symmetric flows', variable=self.sym_var).grid(row=2, column=0, columnspan=2, sticky='w')

        ttk.Label(size_frame, text='Max iterations:').grid(row=3, column=0, sticky='w')
        self.max_iter_var = tk.IntVar(value=self.max_iterations)
        ttk.Entry(size_frame, textvariable=self.max_iter_var, width=8).grid(row=3, column=1, sticky='w')
        # Custom distance matrix option
        self.use_custom_dist_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(size_frame, text='Use custom distance matrix', variable=self.use_custom_dist_var).grid(row=4, column=0, columnspan=2, sticky='w')
        self.sym_dist_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(size_frame, text='Force symmetric distances', variable=self.sym_dist_var).grid(row=5, column=0, columnspan=2, sticky='w')

        # Random generator
        gen_frame = ttk.LabelFrame(control_frame, text='Random Generator')
        gen_frame.pack(fill='x', pady=4)
        ttk.Label(gen_frame, text='Min flow:').grid(row=0, column=0, sticky='w')
        self.min_flow_var = tk.IntVar(value=0)
        ttk.Entry(gen_frame, textvariable=self.min_flow_var, width=6).grid(row=0, column=1)
        ttk.Label(gen_frame, text='Max flow:').grid(row=0, column=2, sticky='w')
        self.max_flow_var = tk.IntVar(value=20)
        ttk.Entry(gen_frame, textvariable=self.max_flow_var, width=6).grid(row=0, column=3)
        ttk.Label(gen_frame, text='Sparsity (0..1):').grid(row=1, column=0, sticky='w')
        self.sparsity_var = tk.DoubleVar(value=0.2)
        ttk.Entry(gen_frame, textvariable=self.sparsity_var, width=6).grid(row=1, column=1)
        ttk.Label(gen_frame, text='Seed (opt):').grid(row=1, column=2, sticky='w')
        self.seed_var = tk.StringVar(value='')
        ttk.Entry(gen_frame, textvariable=self.seed_var, width=8).grid(row=1, column=3)

        ttk.Button(gen_frame, text='Generate Random Problem', command=self.generate_random_problem).grid(row=2, column=0, columnspan=4, pady=4)

        ttk.Button(control_frame, text='Load Example (n=8)', command=self.load_example_8).pack(fill='x', pady=4)

        # Controls for algorithm
        algo_frame = ttk.LabelFrame(control_frame, text='Algorithm Controls')
        algo_frame.pack(fill='x', pady=4)
        ttk.Button(algo_frame, text='Run to End', command=self.run_to_end).grid(row=0, column=0, sticky='ew')
        ttk.Button(algo_frame, text='Next Step', command=self.next_step).grid(row=0, column=1, sticky='ew')
        ttk.Button(algo_frame, text='Previous Step', command=self.prev_step).grid(row=0, column=2, sticky='ew')
        ttk.Button(algo_frame, text='Reset to Initial', command=self.reset_to_initial).grid(row=1, column=0, columnspan=3, sticky='ew')

        ttk.Label(algo_frame, text='Show swaps:').grid(row=2, column=0, sticky='w')
        self.show_all_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(algo_frame, text='All', variable=self.show_all_var).grid(row=2, column=1, sticky='w')
        ttk.Label(algo_frame, text='Top-K:').grid(row=3, column=0, sticky='w')
        self.topk_var = tk.IntVar(value=10)
        ttk.Entry(algo_frame, textvariable=self.topk_var, width=6).grid(row=3, column=1, sticky='w')

        # Export and log
        log_frame = ttk.LabelFrame(control_frame, text='Logging / Export')
        log_frame.pack(fill='x', pady=4)
        ttk.Button(log_frame, text='Export CSV', command=self.export_csv).grid(row=0, column=0, sticky='ew')
        ttk.Button(log_frame, text='Export TXT', command=self.export_txt).grid(row=0, column=1, sticky='ew')
        ttk.Button(log_frame, text='Validate ΔC for current best', command=self.validate_current_delta).grid(row=1, column=0, columnspan=2, pady=4)

        # Right area: visualization and tables
        right_frame = ttk.Frame(self)
        right_frame.pack(side='right', fill='both', expand=True, padx=6, pady=6)

        # Top: layout visualization
        viz_frame = ttk.LabelFrame(right_frame, text='Layout Visualization')
        viz_frame.pack(fill='both', expand=True)
        self.canvas = tk.Canvas(viz_frame, width=640, height=480, bg='white')
        self.canvas.pack(fill='both', expand=True)

        # bottom: tables and detailed info
        bottom_frame = ttk.Frame(right_frame)
        bottom_frame.pack(fill='x')

        # Flow matrix editor
        fm_frame = ttk.LabelFrame(bottom_frame, text='Flow Matrix (editable)')
        fm_frame.pack(side='left', fill='both', expand=True, padx=4)
        self.fm_canvas = tk.Canvas(fm_frame)
        self.fm_canvas.pack(side='left', fill='both', expand=True)
        self.fm_inner = ttk.Frame(self.fm_canvas)
        self.fm_scroll = ttk.Scrollbar(fm_frame, orient='vertical', command=self.fm_canvas.yview)
        self.fm_canvas.configure(yscrollcommand=self.fm_scroll.set)
        self.fm_scroll.pack(side='right', fill='y')
        self.fm_canvas.create_window((0,0), window=self.fm_inner, anchor='nw')
        self.fm_inner.bind('<Configure>', lambda e: self.fm_canvas.configure(scrollregion=self.fm_canvas.bbox('all')))

        # Layout editor
        # Distance matrix editor
        dist_frame = ttk.LabelFrame(bottom_frame, text='Distance Matrix (editable)')
        dist_frame.pack(side='left', fill='both', expand=True, padx=4)
        self.dist_canvas = tk.Canvas(dist_frame)
        self.dist_canvas.pack(side='left', fill='both', expand=True)
        self.dist_inner = ttk.Frame(self.dist_canvas)
        self.dist_scroll = ttk.Scrollbar(dist_frame, orient='vertical', command=self.dist_canvas.yview)
        self.dist_canvas.configure(yscrollcommand=self.dist_scroll.set)
        self.dist_scroll.pack(side='right', fill='y')
        self.dist_canvas.create_window((0,0), window=self.dist_inner, anchor='nw')
        self.dist_inner.bind('<Configure>', lambda e: self.dist_canvas.configure(scrollregion=self.dist_canvas.bbox('all')))

        layout_frame = ttk.LabelFrame(bottom_frame, text='Layout Editor')
        layout_frame.pack(side='left', fill='y', padx=4)
        self.layout_vars = []
        ttk.Label(layout_frame, text='Dept -> Position').pack()
        self.layout_editor_container = ttk.Frame(layout_frame)
        self.layout_editor_container.pack()

        # Swap candidates and explanation
        swap_frame = ttk.LabelFrame(bottom_frame, text='Swap Candidates & Explanation')
        swap_frame.pack(side='right', fill='both', expand=True, padx=4)
        self.swap_text = tk.Text(swap_frame, width=40, height=12, wrap='word')
        self.swap_text.pack(fill='both', expand=True)

        # Status bar
        self.status_var = tk.StringVar(value='Ready')
        status = ttk.Label(self, textvariable=self.status_var, relief='sunken', anchor='w')
        status.pack(side='bottom', fill='x')

    # ---------- Problem and UI updates ----------
    def on_n_change(self):
        try:
            v = int(self.n_var.get())
        except Exception:
            return
        if v < 3 or v > 12:
            messagebox.showerror('Invalid n', 'n must be between 3 and 12')
            return
        self.n = v
        self.names = [f'D{i+1}' for i in range(self.n)]
        self.positions, self.grid_rows, self.grid_cols = make_grid_positions(self.n)
        self.D = compute_distance_matrix(self.positions, self.metric_var.get())
        # reinitialize matrices and layout
        self.F = [[0.0] * self.n for _ in range(self.n)]
        self.layout = list(range(self.n))
        self.history = []
        self.history_index = -1
        self.refresh_all()

    def update_distance(self):
        self.metric = self.metric_var.get()
        # Only recompute from positions when not using custom distance matrix
        if not getattr(self, 'use_custom_dist_var', tk.BooleanVar()).get():
            self.D = compute_distance_matrix(self.positions, self.metric)
        self.refresh_canvas()

    def generate_random_problem(self):
        # Read parameters
        try:
            minf = int(self.min_flow_var.get())
            maxf = int(self.max_flow_var.get())
            sparsity = float(self.sparsity_var.get())
            seed = self.seed_var.get().strip()
        except Exception as e:
            messagebox.showerror('Invalid params', f'Check random generator params: {e}')
            return
        if seed:
            random.seed(seed)
        else:
            random.seed()

        # fill F
        self.F = [[0.0] * self.n for _ in range(self.n)]
        for i in range(self.n):
            for j in range(self.n):
                if i == j:
                    self.F[i][j] = 0.0
                else:
                    if random.random() < sparsity:
                        val = 0.0
                    else:
                        val = random.randint(minf, maxf)
                    self.F[i][j] = float(val)

        if self.sym_var.get():
            for i in range(self.n):
                for j in range(i+1, self.n):
                    avg = (self.F[i][j] + self.F[j][i]) / 2.0
                    self.F[i][j] = self.F[j][i] = avg

        # initial layout: random or structured
        # choose random assignment
        arr = list(range(self.n))
        random.shuffle(arr)
        self.layout = arr

        self.positions, self.grid_rows, self.grid_cols = make_grid_positions(self.n)
        # only set computed D if not using a custom provided distance matrix
        if not getattr(self, 'use_custom_dist_var', tk.BooleanVar()).get():
            self.D = compute_distance_matrix(self.positions, self.metric_var.get())

        # reset history
        self.history = []
        self.history_index = -1
        self.refresh_all()

    def load_example_8(self):
        # small built-in demo with n=8
        self.n = 8
        self.n_var.set(self.n)
        self.names = [f'D{i+1}' for i in range(self.n)]
        self.positions, self.grid_rows, self.grid_cols = make_grid_positions(self.n)
        self.metric = 'manhattan'
        self.metric_var.set(self.metric)
        # load D from positions unless user intends to use custom distances
        if not getattr(self, 'use_custom_dist_var', tk.BooleanVar()).get():
            self.D = compute_distance_matrix(self.positions, self.metric)

        # Example symmetric flow matrix for demo
        demo = [
            [0, 10, 5, 2, 0, 8, 1, 0],
            [10, 0, 3, 0, 2, 0, 0, 6],
            [5, 3, 0, 7, 0, 0, 0, 0],
            [2, 0, 7, 0, 4, 0, 0, 0],
            [0, 2, 0, 4, 0, 9, 0, 0],
            [8, 0, 0, 0, 9, 0, 11, 0],
            [1, 0, 0, 0, 0, 11, 0, 1],
            [0, 6, 0, 0, 0, 0, 1, 0],
        ]
        self.F = [[float(x) for x in row] for row in demo]
        self.layout = list(range(self.n))
        self.history = []
        self.history_index = -1
        self.refresh_all()

    def refresh_all(self):
        self.build_flow_editor()
        self.build_distance_editor()
        self.build_layout_editor()
        self.refresh_canvas()
        self.update_swap_candidates_text()

    def build_flow_editor(self):
        # clear
        for child in self.fm_inner.winfo_children():
            child.destroy()
        self.flow_entries = [[None] * self.n for _ in range(self.n)]
        # header
        ttk.Label(self.fm_inner, text='').grid(row=0, column=0)
        for j in range(self.n):
            ttk.Label(self.fm_inner, text=self.names[j]).grid(row=0, column=1 + j, padx=2)
        for i in range(self.n):
            ttk.Label(self.fm_inner, text=self.names[i]).grid(row=1 + i, column=0, padx=2)
            for j in range(self.n):
                v = tk.StringVar(value=str(int(self.F[i][j]) if self.F[i][j].is_integer() else f'{self.F[i][j]:.2f}'))
                ent = ttk.Entry(self.fm_inner, textvariable=v, width=6)
                ent.grid(row=1 + i, column=1 + j, padx=1, pady=1)
                self.flow_entries[i][j] = v

        # save button
        ttk.Button(self.fm_inner, text='Apply Flow Edits', command=self.apply_flow_edits).grid(row=2 + self.n, column=0, columnspan=self.n + 1, pady=6)

    def build_distance_editor(self):
        # clear
        for child in self.dist_inner.winfo_children():
            child.destroy()
        self.dist_entries = [[None] * self.n for _ in range(self.n)]
        # header
        ttk.Label(self.dist_inner, text='').grid(row=0, column=0)
        for j in range(self.n):
            ttk.Label(self.dist_inner, text=f'P{j}').grid(row=0, column=1 + j, padx=2)
        for i in range(self.n):
            ttk.Label(self.dist_inner, text=f'P{i}').grid(row=1 + i, column=0, padx=2)
            for j in range(self.n):
                v = tk.StringVar(value=str(int(self.D[i][j]) if float(self.D[i][j]).is_integer() else f'{self.D[i][j]:.2f}'))
                ent = ttk.Entry(self.dist_inner, textvariable=v, width=6)
                ent.grid(row=1 + i, column=1 + j, padx=1, pady=1)
                self.dist_entries[i][j] = v

        ttk.Button(self.dist_inner, text='Apply Distance Edits', command=self.apply_distance_edits).grid(row=2 + self.n, column=0, columnspan=self.n + 1, pady=6)

    def apply_distance_edits(self):
        # parse entries; validate
        newD = [[0.0] * self.n for _ in range(self.n)]
        try:
            for i in range(self.n):
                for j in range(self.n):
                    s = self.dist_entries[i][j].get().strip()
                    if s == '':
                        val = 0.0
                    else:
                        val = float(s)
                    if val < 0:
                        raise ValueError('Distances must be non-negative')
                    newD[i][j] = val
        except Exception as e:
            messagebox.showerror('Invalid distances', f'Check distance values: {e}')
            return

        if self.sym_dist_var.get():
            for i in range(self.n):
                for j in range(i+1, self.n):
                    avg = (newD[i][j] + newD[j][i]) / 2.0
                    newD[i][j] = newD[j][i] = avg

        self.D = newD
        # mark that custom distances are in use
        self.use_custom_dist_var.set(True)
        self.update_swap_candidates_text()
        self.status_var.set('Applied distance edits (using custom D)')

    def apply_flow_edits(self):
        # parse entries; validate
        newF = [[0.0] * self.n for _ in range(self.n)]
        try:
            for i in range(self.n):
                for j in range(self.n):
                    s = self.flow_entries[i][j].get().strip()
                    if s == '':
                        val = 0.0
                    else:
                        val = float(s)
                    if val < 0:
                        raise ValueError('Flows must be non-negative')
                    newF[i][j] = val
        except Exception as e:
            messagebox.showerror('Invalid flow', f'Check flow values: {e}')
            return

        if self.sym_var.get():
            # force symmetric by averaging
            for i in range(self.n):
                for j in range(i+1, self.n):
                    avg = (newF[i][j] + newF[j][i]) / 2.0
                    newF[i][j] = newF[j][i] = avg

        self.F = newF
        self.update_swap_candidates_text()
        self.status_var.set('Applied flow edits')

    def build_layout_editor(self):
        for child in self.layout_editor_container.winfo_children():
            child.destroy()
        self.layout_vars = []
        positions_labels = [f'P{p}' for p in range(len(self.positions))]
        for i in range(self.n):
            row = ttk.Frame(self.layout_editor_container)
            row.pack(fill='x')
            ttk.Label(row, text=self.names[i]).pack(side='left')
            sv = tk.IntVar(value=self.layout[i])
            self.layout_vars.append(sv)
            cb = ttk.Combobox(row, textvariable=sv, values=list(range(len(self.positions))), width=4)
            cb.pack(side='left', padx=4)
        ttk.Button(self.layout_editor_container, text='Apply Layout Edits', command=self.apply_layout_edits).pack(pady=4)

    def apply_layout_edits(self):
        try:
            new_layout = [int(v.get()) for v in self.layout_vars]
        except Exception as e:
            messagebox.showerror('Invalid layout', f'{e}')
            return
        # validate uniqueness
        if len(set(new_layout)) != len(new_layout):
            messagebox.showerror('Invalid layout', 'Positions must be unique assignments')
            return
        self.layout = new_layout
        self.history = []
        self.history_index = -1
        self.refresh_canvas()
        self.update_swap_candidates_text()
        self.status_var.set('Applied layout edits')

    # ---------- Visualization ----------
    def refresh_canvas(self):
        self.canvas.delete('all')
        # draw grid based on grid_rows & grid_cols
        w = self.canvas.winfo_width() or 640
        h = self.canvas.winfo_height() or 480
        rows = self.grid_rows
        cols = self.grid_cols
        cell_w = w / max(cols, 1)
        cell_h = h / max(rows, 1)

        # draw cells
        pos_index_to_dept = {self.layout[i]: i for i in range(len(self.layout))}

        for p_idx in range(rows * cols):
            r = p_idx // cols
            c = p_idx % cols
            x0 = c * cell_w
            y0 = r * cell_h
            x1 = x0 + cell_w
            y1 = y0 + cell_h
            if p_idx < len(self.positions):
                if p_idx in pos_index_to_dept:
                    dept = pos_index_to_dept[p_idx]
                    fill = '#cfe8ff'
                    self.canvas.create_rectangle(x0+2, y0+2, x1-2, y1-2, fill=fill, outline='black')
                    self.canvas.create_text((x0 + x1)/2, (y0+y1)/2, text=self.names[dept], font=('Arial', 12, 'bold'))
                else:
                    fill = '#eeeeee'
                    self.canvas.create_rectangle(x0+2, y0+2, x1-2, y1-2, fill=fill, outline='gray')
            else:
                self.canvas.create_rectangle(x0+2, y0+2, x1-2, y1-2, fill='#f9f9f9', outline='gray')

        # show cost
        current_cost = total_cost(self.F, self.D, self.layout)
        self.canvas.create_text(10, 10, anchor='nw', text=f'Cost: {current_cost:.2f}', font=('Arial', 12, 'bold'))

    # ---------- Swap candidate listing and selection ----------
    def compute_all_candidate_deltas(self):
        pairs = []
        n = self.n
        for a in range(n):
            for b in range(a+1, n):
                d = delta_cost_for_swap(self.F, self.D, self.layout, a, b)
                # also compute full recompute after hypothetical swap for validation
                # but we will compute that on demand to save time
                pairs.append(((a, b), d))
        pairs.sort(key=lambda x: x[1])  # ascending by delta (more negative better)
        return pairs

    def update_swap_candidates_text(self):
        pairs = self.compute_all_candidate_deltas()
        show_all = self.show_all_var.get()
        topk = max(1, int(self.topk_var.get()))
        self.swap_text.delete('1.0', 'end')
        current_cost = total_cost(self.F, self.D, self.layout)
        self.swap_text.insert('end', f'Current total cost: {current_cost:.2f}\n')
        self.swap_text.insert('end', f'Total candidate swaps: {len(pairs)}\n\n')
        to_show = pairs if show_all else pairs[:topk]
        for (a, b), d in to_show:
            self.swap_text.insert('end', f'Swap {self.names[a]} <-> {self.names[b]} : ΔC = {d:.4f}\n')

        if pairs and pairs[0][1] < -1e-9:
            best = pairs[0]
            self.swap_text.insert('end', '\nBest improving swap: {} <-> {} ΔC={:.4f}\n'.format(self.names[best[0][0]], self.names[best[0][1]], best[1]))
        else:
            self.swap_text.insert('end', '\nNo improving swap exists (local optimum)\n')

    # ---------- Algorithm steps and control ----------
    def next_step(self):
        # perform a single best swap if exists; record history entry
        pairs = self.compute_all_candidate_deltas()
        if not pairs:
            self.status_var.set('No candidate swaps')
            return
        best_pair, best_delta = pairs[0]
        a, b = best_pair
        if best_delta >= -1e-9:
            self.status_var.set('Local optimum reached; no improving swap')
            return

        old_layout = list(self.layout)
        old_cost = total_cost(self.F, self.D, old_layout)

        # apply swap
        self.layout[a], self.layout[b] = self.layout[b], self.layout[a]
        new_cost = total_cost(self.F, self.D, self.layout)

        # validate delta by recompute
        recompute_delta = new_cost - old_cost
        efficient_delta = best_delta
        ok = abs(recompute_delta - efficient_delta) < 1e-6

        explanation = f"Swapped {self.names[a]} (P{old_layout[a]}) and {self.names[b]} (P{old_layout[b]})."
        if ok:
            explanation += f" ΔC matches: {efficient_delta:.4f}."
        else:
            explanation += f" ΔC mismatch: efficient {efficient_delta:.6f} vs recompute {recompute_delta:.6f}."

        entry = {
            'iteration': len(self.history) + 1,
            'swap': (a, b),
            'delta': efficient_delta,
            'old_cost': old_cost,
            'new_cost': new_cost,
            'layout': list(self.layout),
            'explanation': explanation,
        }
        self.history.append(entry)
        self.history_index = len(self.history) - 1

        self.refresh_canvas()
        self.update_swap_candidates_text()
        self.status_var.set(f'Applied swap {self.names[a]}<->{self.names[b]} (ΔC={efficient_delta:.4f})')

    def prev_step(self):
        if self.history_index < 0:
            self.status_var.set('No previous step')
            return
        # revert last history step
        idx = self.history_index
        if idx == 0:
            # revert to initial (before any steps)
            # initial layout needs to be stored - we used first history; we'll reconstruct
            # Easiest approach: when history_index==0 revert to initial recorded layout by undoing that swap
            entry = self.history[idx]
            a, b = entry['swap']
            # swap back
            self.layout[a], self.layout[b] = self.layout[b], self.layout[a]
            self.history.pop(idx)
            self.history_index = -1
            self.status_var.set('Reverted to initial layout')
        else:
            # undo last swap by swapping the recorded swap
            entry = self.history.pop()
            a, b = entry['swap']
            self.layout[a], self.layout[b] = self.layout[b], self.layout[a]
            self.history_index = len(self.history) - 1
            self.status_var.set(f'Reverted swap {self.names[a]}<->{self.names[b]}')

        self.refresh_canvas()
        self.update_swap_candidates_text()

    def reset_to_initial(self):
        # we cannot infer original initial layout if history grew, so store initial when first change made
        # Simpler: if history empty, do nothing. If not empty, reconstruct initial by reversing all history in reverse.
        if not self.history:
            self.status_var.set('Already at initial')
            return
        # revert all swaps by undoing in reverse order
        for entry in reversed(self.history):
            a, b = entry['swap']
            self.layout[a], self.layout[b] = self.layout[b], self.layout[a]
        cnt = len(self.history)
        self.history = []
        self.history_index = -1
        self.refresh_canvas()
        self.update_swap_candidates_text()
        self.status_var.set(f'Reset to initial (undid {cnt} swaps)')

    def run_to_end(self):
        if self.running:
            # stop
            self.running = False
            if self.run_after_id:
                self.after_cancel(self.run_after_id)
            self.run_after_id = None
            self.status_var.set('Stopped')
            return
        self.running = True
        self.status_var.set('Running to end...')
        self.max_iterations = int(self.max_iter_var.get())
        self.run_loop(0)

    def run_loop(self, iter_count):
        if not self.running:
            return
        if iter_count >= self.max_iterations:
            self.running = False
            self.status_var.set('Max iterations reached')
            return
        # attempt one step
        pairs = self.compute_all_candidate_deltas()
        if not pairs or pairs[0][1] >= -1e-9:
            self.running = False
            self.status_var.set('Finished: local optimum reached')
            return
        self.next_step()
        # schedule next
        self.run_after_id = self.after(200, lambda: self.run_loop(iter_count + 1))

    # ---------- Validation ----------
    def validate_current_delta(self):
        pairs = self.compute_all_candidate_deltas()
        if not pairs:
            messagebox.showinfo('Validate', 'No candidate swaps')
            return
        (a, b), efficient_delta = pairs[0]
        # compute full recompute
        old_layout = list(self.layout)
        old_cost = total_cost(self.F, self.D, old_layout)
        new_layout = list(old_layout)
        new_layout[a], new_layout[b] = new_layout[b], new_layout[a]
        new_cost = total_cost(self.F, self.D, new_layout)
        recompute_delta = new_cost - old_cost
        ok = abs(recompute_delta - efficient_delta) < 1e-6
        msg = f'Best swap {self.names[a]}<->{self.names[b]}\nEfficient ΔC={efficient_delta:.6f}\nRecompute ΔC={recompute_delta:.6f}\nMatch: {ok}'
        messagebox.showinfo('ΔC Validation', msg)

    # ---------- Export ----------
    def export_csv(self):
        if not self.history:
            messagebox.showinfo('Export', 'No history to export')
            return
        f = filedialog.asksaveasfilename(defaultextension='.csv', filetypes=[('CSV files','*.csv')])
        if not f:
            return
        with open(f, 'w', newline='', encoding='utf-8') as fh:
            writer = csv.writer(fh)
            writer.writerow(['iteration', 'swap_a', 'swap_b', 'delta', 'old_cost', 'new_cost', 'layout', 'explanation'])
            for e in self.history:
                a, b = e['swap']
                writer.writerow([e['iteration'], self.names[a], self.names[b], e['delta'], e['old_cost'], e['new_cost'], ';'.join(map(str,e['layout'])), e['explanation']])
        self.status_var.set(f'Exported CSV to {f}')

    def export_txt(self):
        f = filedialog.asksaveasfilename(defaultextension='.txt', filetypes=[('Text files','*.txt')])
        if not f:
            return
        with open(f, 'w', encoding='utf-8') as fh:
            fh.write('Pairwise Exchange Method Report\n')
            fh.write('===============================\n')
            fh.write(f'n = {self.n}\n')
            fh.write(f'Metric = {self.metric_var.get()}\n')
            fh.write('\nInitial layout: (as starting before any recorded swaps)\n')
            # reconstruct initial layout by undoing history on a copy
            if self.history:
                # start from current layout and undo
                cur = list(self.layout)
                # to get initial, undo in reverse history
                for entry in reversed(self.history):
                    a, b = entry['swap']
                    cur[a], cur[b] = cur[b], cur[a]
                initial_layout = cur
            else:
                initial_layout = self.layout
            fh.write(' '.join([f'{self.names[i]}->P{initial_layout[i]}' for i in range(self.n)]) + '\n')
            fh.write('\nFinal layout: \n')
            fh.write(' '.join([f'{self.names[i]}->P{self.layout[i]}' for i in range(self.n)]) + '\n')
            initial_cost = total_cost(self.F, self.D, initial_layout)
            final_cost = total_cost(self.F, self.D, self.layout)
            fh.write(f'Initial cost: {initial_cost:.4f}\n')
            fh.write(f'Final cost: {final_cost:.4f}\n')
            fh.write(f'Number of swaps: {len(self.history)}\n')
            fh.write('\nSteps:\n')
            for e in self.history:
                a, b = e['swap']
                fh.write(f"{e['iteration']}: swap {self.names[a]}<->{self.names[b]}, ΔC={e['delta']:.4f}, old={e['old_cost']:.4f}, new={e['new_cost']:.4f}\n")
        self.status_var.set(f'Exported TXT to {f}')


if __name__ == '__main__':
    app = PairwiseExchangeApp()
    app.mainloop()
