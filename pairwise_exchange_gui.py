"""
pairwise_exchange_gui.py

How to run:
 - Ensure you have Python 3 (standard library only).
 - Run: `python pairwise_exchange_gui.py`

This Tkinter app demonstrates the Pairwise Exchange Method for facility
layout design. It includes random problem generation, manual editing of the
flow matrix and layout, step-by-step execution (Next/Previous), Run to End
with a responsive UI, visualization of the layout, and export of logs.

Features:
 - n departments (3..12), default 8
 - grid layout computed to fit n (rows = ceil(sqrt(n)))
 - flows: random generator with seed, min/max/sparsity and symmetric toggle
 - distances: Manhattan (default) or Euclidean
 - algorithm: pairwise exchange choosing best improving swap by ΔC
 - displays both ΔC (efficient calc) and full-cost recomputation for validation
 - history logging and export (CSV + TXT)

Notes on cost computation and ΔC (short): see GUI Help -> "ΔC explanation"

Author: Generated by an assistant. Inline comments provided.
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import math
import random
import csv
import json

# ---------- Utility functions ----------

def ceil_sqrt(n):
    r = int(math.ceil(math.sqrt(n)))
    return r

def make_grid_positions(n, rows=None, cols=None):
    # If rows/cols are provided, use them (allow asymmetric layouts).
    if rows is None and cols is None:
        rows = ceil_sqrt(n)
        cols = int(math.ceil(n / rows))
    elif rows is None:
        rows = int(math.ceil(n / cols))
    elif cols is None:
        cols = int(math.ceil(n / rows))

    # Ensure we have enough cells
    if rows * cols < n:
        cols = int(math.ceil(n / rows))

    positions = []
    idx = 0
    for r in range(rows):
        for c in range(cols):
            positions.append((r, c))
            idx += 1
    return positions[:rows * cols], rows, cols

def manhattan(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def euclidean(a, b):
    return math.hypot(a[0] - b[0], a[1] - b[1])

# ---------- Core algorithm functions ----------

def compute_distance_matrix(positions, metric='manhattan'):
    npos = len(positions)
    D = [[0.0] * npos for _ in range(npos)]
    for p in range(npos):
        for q in range(npos):
            if metric == 'manhattan':
                D[p][q] = manhattan(positions[p], positions[q])
            else:
                D[p][q] = euclidean(positions[p], positions[q])
    return D

def total_cost(F, D, layout):
    # Full double-sum as specified: sum_{i=1..n} sum_{j=1..n} F[i][j]*D[L(i),L(j)]
    n = len(F)
    cost = 0.0
    for i in range(n):
        for j in range(n):
            cost += F[i][j] * D[layout[i]][layout[j]]
    return cost

def delta_cost_for_swap(F, D, layout, a, b):
    # Efficient ΔC computation by summing only terms affected by swapping a and b.
    # layout: list mapping department -> position index
    n = len(F)
    pa = layout[a]
    pb = layout[b]
    delta = 0.0

    for k in range(n):
        if k == a or k == b:
            continue
        pk = layout[k]
        # contribution change when i==a or j==a
        delta += F[a][k] * (D[pb][pk] - D[pa][pk])
        delta += F[k][a] * (D[pk][pb] - D[pk][pa])
        # contribution change when i==b or j==b
        delta += F[b][k] * (D[pa][pk] - D[pb][pk])
        delta += F[k][b] * (D[pk][pa] - D[pk][pb])

    # terms where i and j are a or b
    delta += F[a][a] * (D[pb][pb] - D[pa][pa])
    delta += F[b][b] * (D[pa][pa] - D[pb][pb])

    # cross terms a<->b
    delta += F[a][b] * (D[pb][pa] - D[pa][pb])
    delta += F[b][a] * (D[pa][pb] - D[pb][pa])

    return delta

# ---------- GUI Application ----------

class PairwiseExchangeApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title('Pairwise Exchange Method - Teaching App')
        self.geometry('1200x780')
        try:
            self.state('zoomed')
        except Exception:
            pass

        # Model state
        self.n = 9
        self.names = [f'D{i+1}' for i in range(self.n)]
        self.positions, self.grid_rows, self.grid_cols = make_grid_positions(self.n)
        self.metric = 'manhattan'  # or 'euclidean'
        self.force_symmetric = True
        self.max_iterations = 1000
        self.show_all_swaps = True
        self.top_k = 10

        # default matrices
        self.F = [[0.0] * self.n for _ in range(self.n)]
        self.D = compute_distance_matrix(self.positions, self.metric)
        self.layout = list(range(self.n))  # department i -> position index

        # history of steps
        self.history = []  # list of dicts with iteration info
        self.history_index = -1

        # Running flag and after() id
        self.running = False
        self.run_after_id = None
        # Drag-and-drop state for swapping departments
        self.drag_active = False
        self.drag_start_pos = None
        self.drag_over_pos = None
        # Temporary highlight after swaps
        self.highlight_positions = set()
        self.highlight_after_id = None

        # Build UI
        self.create_widgets()

        # Initialize default empty problem state
        self.refresh_all()
        self.after(50, self.refresh_canvas)

    # ---------- UI building ----------
    def create_widgets(self):
        main_pane = ttk.Panedwindow(self, orient='horizontal')
        main_pane.pack(fill='both', expand=True, padx=6, pady=6)

        control_frame = ttk.Frame(main_pane, padding=6)
        main_pane.add(control_frame, weight=1)
        control_frame.columnconfigure(0, weight=1)

        style = ttk.Style(self)
        style.configure('Problem.TLabelframe', background='#f3f7ff')
        style.configure('Problem.TLabelframe.Label', background='#f3f7ff')
        style.configure('Problem.TLabel', background='#f3f7ff')
        style.configure('Problem.TCheckbutton', background='#f3f7ff')
        style.configure('Problem.TButton', background='#dde7ff')
        style.configure('Random.TLabelframe', background='#f7f3ff')
        style.configure('Random.TLabelframe.Label', background='#f7f3ff')
        style.configure('Random.TLabel', background='#f7f3ff')
        style.configure('Random.TButton', background='#e7ddff')
        style.configure('Algo.TLabelframe', background='#f3fff7')
        style.configure('Algo.TLabelframe.Label', background='#f3fff7')
        style.configure('Algo.TButton', background='#ddffe7')
        style.configure('Log.TLabelframe', background='#fff7f3')
        style.configure('Log.TLabelframe.Label', background='#fff7f3')
        style.configure('Log.TButton', background='#ffe7dd')
        style.configure('MatrixApply.TButton', background='#dcecff')
        style.configure('Quick.TButton', background='#f2f2f2', font=('Arial', 8))

        # Problem size
        size_frame = ttk.LabelFrame(control_frame, text='Problem', style='Problem.TLabelframe', padding=6)
        size_frame.grid(row=0, column=0, sticky='nsew', pady=4)
        self._add_info_button(
            size_frame,
            "Problem setup: n, grid size, distance metric, and symmetry options.\n"
            "Rows*Cols must be >= n. Metric affects distances when Custom Distance is OFF."
        )
        ttk.Label(size_frame, text='n (3..12):', style='Problem.TLabel').grid(row=0, column=0, sticky='w')
        self.n_var = tk.IntVar(value=self.n)
        n_spin = ttk.Spinbox(size_frame, from_=3, to=12, textvariable=self.n_var, width=5,
                             command=self.on_n_change)
        n_spin.grid(row=0, column=1, sticky='w')
        n_spin.bind('<FocusOut>', lambda e: self.on_n_change())
        n_spin.bind('<Return>', lambda e: self.on_n_change())

        ttk.Label(size_frame, text='Rows:', style='Problem.TLabel').grid(row=0, column=2, sticky='w')
        self.rows_var = tk.IntVar(value=self.grid_rows)
        rows_spin = ttk.Spinbox(size_frame, from_=1, to=12, textvariable=self.rows_var, width=5,
                    command=self.on_rows_cols_change)
        rows_spin.grid(row=0, column=3, sticky='w')
        ttk.Label(size_frame, text='Cols:', style='Problem.TLabel').grid(row=1, column=2, sticky='w')
        self.cols_var = tk.IntVar(value=self.grid_cols)
        cols_spin = ttk.Spinbox(size_frame, from_=1, to=12, textvariable=self.cols_var, width=5,
                    command=self.on_rows_cols_change)
        cols_spin.grid(row=1, column=3, sticky='w')

        ttk.Label(size_frame, text='Metric:', style='Problem.TLabel').grid(row=1, column=0, sticky='w')
        self.metric_var = tk.StringVar(value=self.metric)
        metric_combo = ttk.Combobox(size_frame, textvariable=self.metric_var,
                                    values=['manhattan', 'euclidean'], state='readonly', width=10)
        metric_combo.grid(row=1, column=1, sticky='w')
        metric_combo.bind('<<ComboboxSelected>>', lambda e: self.update_distance())

        self.sym_var = tk.BooleanVar(value=self.force_symmetric)
        ttk.Checkbutton(size_frame, text='Force symmetric flows', variable=self.sym_var, style='Problem.TCheckbutton').grid(row=2, column=0, columnspan=2, sticky='w')

        ttk.Label(size_frame, text='Max iterations:', style='Problem.TLabel').grid(row=3, column=0, sticky='w')
        self.max_iter_var = tk.IntVar(value=self.max_iterations)
        ttk.Entry(size_frame, textvariable=self.max_iter_var, width=8).grid(row=3, column=1, sticky='w')
        # Custom distance matrix option
        self.use_custom_dist_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(
            size_frame,
            text='Use custom distance matrix',
            variable=self.use_custom_dist_var,
            command=self.on_use_custom_distance_toggle,
            style='Problem.TCheckbutton'
        ).grid(row=4, column=0, columnspan=2, sticky='w')
        self.sym_dist_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(size_frame, text='Force symmetric distances', variable=self.sym_dist_var, style='Problem.TCheckbutton').grid(row=5, column=0, columnspan=2, sticky='w')
        # track last valid grid to prevent invalid downsizing
        self._last_valid_rows = self.grid_rows
        self._last_valid_cols = self.grid_cols
        self._rows_cols_guard = False

        # Random generator
        gen_frame = ttk.LabelFrame(control_frame, text='Random Generator', style='Random.TLabelframe', padding=6)
        gen_frame.grid(row=1, column=0, sticky='nsew', pady=4)
        self._add_info_button(
            gen_frame,
            "Randomize Flow and (optionally) Distance matrices.\n"
            "Uses current Rows/Cols if valid. Seeds make results repeatable."
        )
        gen_frame.columnconfigure(0, weight=1)

        flow_frame = ttk.LabelFrame(gen_frame, text='Flow', style='Random.TLabelframe')
        flow_frame.grid(row=0, column=0, sticky='nsew', padx=4, pady=4)
        dist_frame = ttk.LabelFrame(gen_frame, text='Distance', style='Random.TLabelframe')
        dist_frame.grid(row=1, column=0, sticky='nsew', padx=4, pady=4)

        ttk.Label(flow_frame, text='Min:', style='Random.TLabel').grid(row=0, column=0, sticky='w')
        self.min_flow_var = tk.IntVar(value=0)
        ttk.Entry(flow_frame, textvariable=self.min_flow_var, width=6).grid(row=0, column=1, sticky='w')
        ttk.Label(flow_frame, text='Max:', style='Random.TLabel').grid(row=0, column=2, sticky='w')
        self.max_flow_var = tk.IntVar(value=20)
        ttk.Entry(flow_frame, textvariable=self.max_flow_var, width=6).grid(row=0, column=3, sticky='w')
        ttk.Label(flow_frame, text='Sparsity (0..1):', style='Random.TLabel').grid(row=1, column=0, sticky='w')
        self.sparsity_var = tk.DoubleVar(value=0.2)
        ttk.Entry(flow_frame, textvariable=self.sparsity_var, width=6).grid(row=1, column=1, sticky='w')
        ttk.Label(flow_frame, text='Seed (opt):', style='Random.TLabel').grid(row=1, column=2, sticky='w')
        self.seed_var = tk.StringVar(value='')
        ttk.Entry(flow_frame, textvariable=self.seed_var, width=8).grid(row=1, column=3, sticky='w')

        ttk.Label(dist_frame, text='Min:', style='Random.TLabel').grid(row=0, column=0, sticky='w')
        self.min_dist_var = tk.IntVar(value=1)
        ttk.Entry(dist_frame, textvariable=self.min_dist_var, width=6).grid(row=0, column=1, sticky='w')
        ttk.Label(dist_frame, text='Max:', style='Random.TLabel').grid(row=0, column=2, sticky='w')
        self.max_dist_var = tk.IntVar(value=20)
        ttk.Entry(dist_frame, textvariable=self.max_dist_var, width=6).grid(row=0, column=3, sticky='w')
        ttk.Label(dist_frame, text='Sparsity (0..1):', style='Random.TLabel').grid(row=1, column=0, sticky='w')
        self.dist_sparsity_var = tk.DoubleVar(value=0.0)
        ttk.Entry(dist_frame, textvariable=self.dist_sparsity_var, width=6).grid(row=1, column=1, sticky='w')
        ttk.Label(dist_frame, text='Seed (opt):', style='Random.TLabel').grid(row=1, column=2, sticky='w')
        self.dist_seed_var = tk.StringVar(value='')
        ttk.Entry(dist_frame, textvariable=self.dist_seed_var, width=8).grid(row=1, column=3, sticky='w')

        ttk.Button(gen_frame, text='Generate Random Problem', command=self.generate_random_problem, style='Random.TButton').grid(row=2, column=0, pady=4)

        # Controls for algorithm
        algo_frame = ttk.LabelFrame(control_frame, text='Algorithm Controls', style='Algo.TLabelframe', padding=6)
        algo_frame.grid(row=2, column=0, sticky='nsew', pady=4)
        self._add_info_button(
            algo_frame,
            "Algorithm controls: run, step, undo, reset.\n"
            "Show swaps list and Top-K options are below."
        )
        ttk.Button(algo_frame, text='Run to End', command=self.run_to_end, style='Algo.TButton').grid(row=0, column=0, sticky='ew')
        ttk.Button(algo_frame, text='Next Step', command=self.next_step, style='Algo.TButton').grid(row=0, column=1, sticky='ew')
        ttk.Button(algo_frame, text='Previous Step', command=self.prev_step, style='Algo.TButton').grid(row=0, column=2, sticky='ew')
        ttk.Button(algo_frame, text='Reset to Initial', command=self.reset_to_initial, style='Algo.TButton').grid(row=1, column=0, columnspan=3, sticky='ew')

        ttk.Label(algo_frame, text='Show swaps:').grid(row=2, column=0, sticky='w')
        self.show_all_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(algo_frame, text='All', variable=self.show_all_var).grid(row=2, column=1, sticky='w')
        ttk.Label(algo_frame, text='Top-K:').grid(row=3, column=0, sticky='w')
        self.topk_var = tk.IntVar(value=10)
        ttk.Entry(algo_frame, textvariable=self.topk_var, width=6).grid(row=3, column=1, sticky='w')

        # Export and log
        log_frame = ttk.LabelFrame(control_frame, text='Logging / Export', style='Log.TLabelframe', padding=6)
        log_frame.grid(row=3, column=0, sticky='nsew', pady=4)
        self._add_info_button(
            log_frame,
            "Export history (CSV/TXT), save/load project state, and validate ΔC accuracy."
        )
        ttk.Button(log_frame, text='Export CSV', command=self.export_csv, style='Log.TButton').grid(row=0, column=0, sticky='ew')
        ttk.Button(log_frame, text='Export TXT', command=self.export_txt, style='Log.TButton').grid(row=0, column=1, sticky='ew')
        ttk.Button(log_frame, text='Save Project', command=self.save_project, style='Log.TButton').grid(row=1, column=0, sticky='ew', pady=(2, 0))
        ttk.Button(log_frame, text='Load Project', command=self.load_project, style='Log.TButton').grid(row=1, column=1, sticky='ew', pady=(2, 0))
        ttk.Button(log_frame, text='Validate ΔC for current best', command=self.validate_current_delta, style='Log.TButton').grid(row=2, column=0, columnspan=2, pady=(2, 4))

        quick_help_btn = ttk.Button(
            control_frame,
            text='Quick Guide',
            command=self.show_quick_help,
            style='Quick.TButton'
        )
        quick_help_btn.grid(row=4, column=0, sticky='w', pady=(4, 2))

        control_frame.rowconfigure(0, weight=2)
        control_frame.rowconfigure(1, weight=3)
        control_frame.rowconfigure(2, weight=2)
        control_frame.rowconfigure(3, weight=1)
        control_frame.rowconfigure(4, weight=0)

        # Right area: visualization, tables, and swap panel
        right_frame = ttk.Frame(main_pane, padding=6)
        main_pane.add(right_frame, weight=4)

        # Right column: swap candidates span top-to-bottom
        swap_frame = ttk.LabelFrame(right_frame, text='Swap Candidates & Explanation')
        swap_frame.pack(side='right', fill='y', padx=4, pady=4)
        self.swap_text = tk.Text(swap_frame, width=40, height=12, wrap='word')
        self.swap_text.pack(fill='both', expand=True)

        # Left content: visualization and editors
        content_frame = ttk.Frame(right_frame)
        content_frame.pack(side='left', fill='both', expand=True)

        # Top: layout visualization
        viz_frame = ttk.LabelFrame(content_frame, text='Layout Visualization', padding=6)
        viz_frame.pack(fill='both', expand=True)
        viz_frame.columnconfigure(0, weight=1)
        viz_frame.rowconfigure(0, weight=1)
        self.canvas = tk.Canvas(viz_frame, width=640, height=480, bg='white')
        self.canvas.grid(row=0, column=0, sticky='nsew')
        self.drag_hint_label = ttk.Label(
            viz_frame,
            text='Tip: Drag and drop to swap any two departments (P# shows positions).',
            foreground='#666666',
            font=('Arial', 9, 'italic')
        )
        self.drag_hint_label.grid(row=1, column=0, sticky='e', pady=(4, 0))
        self.canvas.bind('<Configure>', lambda e: self.refresh_canvas())
        self.canvas.bind('<ButtonPress-1>', self.on_canvas_press)
        self.canvas.bind('<B1-Motion>', self.on_canvas_drag)
        self.canvas.bind('<ButtonRelease-1>', self.on_canvas_release)

        # bottom: tables and detailed info
        matrix_toolbar = ttk.Frame(content_frame)
        matrix_toolbar.pack(fill='x', pady=(2, 2))
        matrix_toolbar.columnconfigure(0, weight=1, uniform='mat')
        matrix_toolbar.columnconfigure(1, weight=1, uniform='mat')
        flow_toolbar = ttk.Frame(matrix_toolbar)
        dist_toolbar = ttk.Frame(matrix_toolbar)
        flow_toolbar.grid(row=0, column=0, sticky='nsew')
        dist_toolbar.grid(row=0, column=1, sticky='nsew')
        self.apply_flow_btn = ttk.Button(
            flow_toolbar,
            text='Apply Flow Edits',
            command=self.apply_flow_edits,
            style='MatrixApply.TButton'
        )
        self.apply_flow_btn.pack(pady=2)
        self.apply_dist_btn = ttk.Button(
            dist_toolbar,
            text='Apply Distance Edits',
            command=self.apply_distance_edits,
            style='MatrixApply.TButton'
        )
        self.apply_dist_btn.pack(pady=2)

        bottom_pane = ttk.Panedwindow(content_frame, orient='horizontal')
        bottom_pane.pack(fill='both', expand=True)

        # Flow matrix editor
        self.fm_frame = ttk.LabelFrame(bottom_pane, text='Flow Matrix (editable)', padding=6)
        bottom_pane.add(self.fm_frame, weight=1)
        fm_container = ttk.Frame(self.fm_frame)
        fm_container.pack(fill='both', expand=True)
        fm_container.columnconfigure(0, weight=1)
        fm_container.rowconfigure(0, weight=1)

        self.fm_canvas = tk.Canvas(fm_container)
        self.fm_canvas.grid(row=0, column=0, sticky='nsew')
        self.fm_canvas.configure(highlightthickness=1, highlightbackground='#c7d2e8')
        self.fm_inner = ttk.Frame(self.fm_canvas)
        # vertical + horizontal scrollbars for responsiveness
        self.fm_scroll = ttk.Scrollbar(fm_container, orient='vertical', command=self.fm_canvas.yview)
        self.fm_hscroll = ttk.Scrollbar(fm_container, orient='horizontal', command=self.fm_canvas.xview)
        self.fm_canvas.configure(yscrollcommand=self.fm_scroll.set, xscrollcommand=self.fm_hscroll.set)
        self.fm_scroll.grid(row=0, column=1, sticky='ns')
        self.fm_hscroll.grid(row=1, column=0, sticky='ew')
        self.fm_window = self.fm_canvas.create_window((0,0), window=self.fm_inner, anchor='nw')
        # keep inner sized to canvas width and update scrollregion
        self.fm_inner.bind('<Configure>', lambda e: self.fm_canvas.configure(scrollregion=self.fm_canvas.bbox('all')))
        # do not force inner width to canvas width — allow horizontal scrolling

        # Distance matrix editor
        self.dist_frame = ttk.LabelFrame(bottom_pane, text='Distance Matrix (editable)', padding=6)
        bottom_pane.add(self.dist_frame, weight=1)
        dist_container = ttk.Frame(self.dist_frame)
        dist_container.pack(fill='both', expand=True)
        dist_container.columnconfigure(0, weight=1)
        dist_container.rowconfigure(0, weight=1)

        self.dist_canvas = tk.Canvas(dist_container)
        self.dist_canvas.grid(row=0, column=0, sticky='nsew')
        self.dist_canvas.configure(highlightthickness=1, highlightbackground='#c7d2e8')
        self.dist_inner = ttk.Frame(self.dist_canvas)
        self.dist_scroll = ttk.Scrollbar(dist_container, orient='vertical', command=self.dist_canvas.yview)
        self.dist_hscroll = ttk.Scrollbar(dist_container, orient='horizontal', command=self.dist_canvas.xview)
        self.dist_canvas.configure(yscrollcommand=self.dist_scroll.set, xscrollcommand=self.dist_hscroll.set)
        self.dist_scroll.grid(row=0, column=1, sticky='ns')
        self.dist_hscroll.grid(row=1, column=0, sticky='ew')
        self.dist_window = self.dist_canvas.create_window((0,0), window=self.dist_inner, anchor='nw')
        self.dist_inner.bind('<Configure>', lambda e: self.dist_canvas.configure(scrollregion=self.dist_canvas.bbox('all')))
        # do not force inner width to canvas width — allow horizontal scrolling

        # Status bar
        self.status_var = tk.StringVar(value='Ready')
        status = ttk.Label(self, textvariable=self.status_var, relief='sunken', anchor='w')
        status.pack(side='bottom', fill='x')

    # ---------- Problem and UI updates ----------
    def on_n_change(self):
        try:
            v = int(self.n_var.get())
        except Exception:
            return
        if v < 3 or v > 12:
            messagebox.showerror('Invalid n', 'n must be between 3 and 12')
            return
        self.n = v
        self.names = [f'D{i+1}' for i in range(self.n)]
        self.positions, self.grid_rows, self.grid_cols = make_grid_positions(self.n)
        # reflect into rows/cols controls
        try:
            self.rows_var.set(self.grid_rows)
            self.cols_var.set(self.grid_cols)
        except Exception:
            pass
        self._last_valid_rows = self.grid_rows
        self._last_valid_cols = self.grid_cols
        self.D = compute_distance_matrix(self.positions, self.metric_var.get())
        # reinitialize matrices and layout
        self.F = [[0.0] * self.n for _ in range(self.n)]
        self.layout = list(range(self.n))
        self.history = []
        self.history_index = -1
        self.refresh_all()

    def update_distance(self):
        self.metric = self.metric_var.get()
        # Only recompute from positions when not using custom distance matrix
        if not getattr(self, 'use_custom_dist_var', tk.BooleanVar()).get():
            self.D = compute_distance_matrix(self.positions, self.metric)
            self.build_distance_editor()
        self.refresh_canvas()

    def on_use_custom_distance_toggle(self):
        if self.use_custom_dist_var.get():
            self.build_distance_editor()
            if hasattr(self, 'apply_dist_btn'):
                self.apply_dist_btn.configure(state='normal')
            self.status_var.set('Using custom distance matrix')
            return
        self.metric = self.metric_var.get()
        self.D = compute_distance_matrix(self.positions, self.metric)
        self.build_distance_editor()
        if hasattr(self, 'apply_dist_btn'):
            self.apply_dist_btn.configure(state='disabled')
        self.update_swap_candidates_text()
        self.refresh_canvas()
        self.status_var.set('Using computed distance matrix')

    def _refresh_distance_if_computed(self):
        if self.use_custom_dist_var.get():
            if hasattr(self, 'apply_dist_btn'):
                self.apply_dist_btn.configure(state='normal')
            return
        self.metric = self.metric_var.get()
        self.D = compute_distance_matrix(self.positions, self.metric)
        self.build_distance_editor()
        if hasattr(self, 'apply_dist_btn'):
            self.apply_dist_btn.configure(state='disabled')

    def generate_random_problem(self):
        # Read parameters
        try:
            minf = int(self.min_flow_var.get())
            maxf = int(self.max_flow_var.get())
            sparsity = float(self.sparsity_var.get())
            seed = self.seed_var.get().strip()
            mind = int(self.min_dist_var.get())
            maxd = int(self.max_dist_var.get())
            dist_sparsity = float(self.dist_sparsity_var.get())
            dist_seed = self.dist_seed_var.get().strip()
        except Exception as e:
            messagebox.showerror('Invalid params', f'Check random generator params: {e}')
            return
        if seed:
            random.seed(seed)
        else:
            random.seed()

        # fill F
        self.F = [[0.0] * self.n for _ in range(self.n)]
        for i in range(self.n):
            for j in range(self.n):
                if i == j:
                    self.F[i][j] = 0.0
                else:
                    if random.random() < sparsity:
                        val = 0.0
                    else:
                        val = random.randint(minf, maxf)
                    self.F[i][j] = float(val)

        if self.sym_var.get():
            for i in range(self.n):
                for j in range(i+1, self.n):
                    avg = (self.F[i][j] + self.F[j][i]) / 2.0
                    self.F[i][j] = self.F[j][i] = avg

        # initial layout: random or structured
        # choose random assignment
        arr = list(range(self.n))
        random.shuffle(arr)
        self.layout = arr

        # keep current rows/cols if valid, otherwise compute a new grid
        try:
            r = int(self.rows_var.get())
            c = int(self.cols_var.get())
        except Exception:
            r, c = None, None
        if r and c and r > 0 and c > 0 and r * c >= self.n:
            self.positions, self.grid_rows, self.grid_cols = make_grid_positions(self.n, rows=r, cols=c)
        else:
            self.positions, self.grid_rows, self.grid_cols = make_grid_positions(self.n)
            try:
                self.rows_var.set(self.grid_rows)
                self.cols_var.set(self.grid_cols)
            except Exception:
                pass
        # distance matrix: random if custom enabled, otherwise computed from positions
        if getattr(self, 'use_custom_dist_var', tk.BooleanVar()).get():
            if dist_seed:
                random.seed(dist_seed)
            else:
                random.seed()
            newD = [[0.0] * self.n for _ in range(self.n)]
            for i in range(self.n):
                for j in range(self.n):
                    if i == j:
                        newD[i][j] = 0.0
                    else:
                        if random.random() < dist_sparsity:
                            val = 0.0
                        else:
                            val = random.randint(mind, maxd)
                        newD[i][j] = float(val)
            if self.sym_dist_var.get():
                for i in range(self.n):
                    for j in range(i+1, self.n):
                        avg = (newD[i][j] + newD[j][i]) / 2.0
                        newD[i][j] = newD[j][i] = avg
            self.D = newD
        else:
            self.D = compute_distance_matrix(self.positions, self.metric_var.get())

        # reset history
        self.history = []
        self.history_index = -1
        self.refresh_all()

    def refresh_all(self):
        self.build_flow_editor()
        self.build_distance_editor()
        self.refresh_canvas()
        self._refresh_distance_if_computed()
        self.update_swap_candidates_text()

    def build_flow_editor(self):
        # clear
        for child in self.fm_inner.winfo_children():
            child.destroy()
        # keep both StringVar matrix and widget matrix
        self.flow_vars = [[None] * self.n for _ in range(self.n)]
        self.flow_entry_widgets = [[None] * self.n for _ in range(self.n)]
        # guard to avoid recursive updates when mirroring
        if not hasattr(self, '_updating_mirror'):
            self._updating_mirror = False
        # header
        ttk.Label(self.fm_inner, text='').grid(row=0, column=0)
        for j in range(self.n):
            ttk.Label(self.fm_inner, text=self.names[j]).grid(row=0, column=1 + j, padx=2)
        for i in range(self.n):
            ttk.Label(self.fm_inner, text=self.names[i]).grid(row=1 + i, column=0, padx=2)
            for j in range(self.n):
                v = tk.StringVar(value=str(int(self.F[i][j]) if self.F[i][j].is_integer() else f'{self.F[i][j]:.2f}'))
                ent = tk.Entry(self.fm_inner, textvariable=v, width=self._matrix_entry_width())
                ent.grid(row=1 + i, column=1 + j, padx=1, pady=1)
                self.flow_vars[i][j] = v
                self.flow_entry_widgets[i][j] = ent
                # bind events to mirror symmetric cell when editing
                ent.bind('<FocusOut>', lambda e, a=i, b=j: self.on_flow_cell_changed(a, b))
                ent.bind('<KeyRelease>', lambda e, a=i, b=j: self.on_flow_cell_changed(a, b))

        # apply button lives in shared toolbar

    def build_distance_editor(self):
        # clear
        for child in self.dist_inner.winfo_children():
            child.destroy()
        self.dist_vars = [[None] * self.n for _ in range(self.n)]
        self.dist_entry_widgets = [[None] * self.n for _ in range(self.n)]
        if not hasattr(self, '_updating_mirror'):
            self._updating_mirror = False
        use_custom = self.use_custom_dist_var.get()
        if use_custom:
            labels = [f'P{j}' for j in range(self.n)]
            matrix = self.D
            self.dist_frame.configure(text='Distance Matrix (editable)')
        else:
            labels = list(self.names)
            matrix = [[self.D[self.layout[i]][self.layout[j]] for j in range(self.n)] for i in range(self.n)]
            self.dist_frame.configure(text='Distance Matrix (current layout)')
        # header
        ttk.Label(self.dist_inner, text='').grid(row=0, column=0)
        for j in range(self.n):
            ttk.Label(self.dist_inner, text=labels[j]).grid(row=0, column=1 + j, padx=2)
        for i in range(self.n):
            ttk.Label(self.dist_inner, text=labels[i]).grid(row=1 + i, column=0, padx=2)
            for j in range(self.n):
                val = matrix[i][j]
                v = tk.StringVar(value=str(int(val) if float(val).is_integer() else f'{val:.2f}'))
                ent = tk.Entry(self.dist_inner, textvariable=v, width=self._matrix_entry_width())
                ent.grid(row=1 + i, column=1 + j, padx=1, pady=1)
                if not use_custom:
                    ent.configure(state='disabled', disabledbackground='#f0f0f0')
                self.dist_vars[i][j] = v
                self.dist_entry_widgets[i][j] = ent
                if use_custom:
                    ent.bind('<FocusOut>', lambda e, a=i, b=j: self.on_dist_cell_changed(a, b))
                    ent.bind('<KeyRelease>', lambda e, a=i, b=j: self.on_dist_cell_changed(a, b))

        if hasattr(self, 'apply_dist_btn'):
            self.apply_dist_btn.configure(state=('normal' if use_custom else 'disabled'))

    def apply_distance_edits(self):
        # parse entries; validate
        newD = [[0.0] * self.n for _ in range(self.n)]
        try:
            for i in range(self.n):
                for j in range(self.n):
                    s = self.dist_vars[i][j].get().strip()
                    if s == '':
                        val = 0.0
                    else:
                        val = float(s)
                    if val < 0:
                        raise ValueError('Distances must be non-negative')
                    newD[i][j] = val
        except Exception as e:
            messagebox.showerror('Invalid distances', f'Check distance values: {e}')
            return

        if self.sym_dist_var.get():
            for i in range(self.n):
                for j in range(i+1, self.n):
                    avg = (newD[i][j] + newD[j][i]) / 2.0
                    newD[i][j] = newD[j][i] = avg

        self.D = newD
        # mark that custom distances are in use
        self.use_custom_dist_var.set(True)
        self.update_swap_candidates_text()
        self.status_var.set('Applied distance edits (using custom D)')

    def on_dist_cell_changed(self, i, j):
        # called when a distance cell is edited; mirror to [j][i] if symmetry requested
        if not self.use_custom_dist_var.get():
            return
        if self._updating_mirror:
            return
        try:
            s = self.dist_vars[i][j].get().strip()
            val = 0.0 if s == '' else float(s)
            if val < 0:
                return
        except Exception:
            return
        # update internal D
        self.D[i][j] = val
        if self.sym_dist_var.get():
            # mirror
            try:
                self._updating_mirror = True
                self.dist_vars[j][i].set(str(int(val) if float(val).is_integer() else f'{val:.2f}'))
                self.D[j][i] = val
            finally:
                self._updating_mirror = False
        # mark custom distances in use
        self.use_custom_dist_var.set(True)
        self.update_swap_candidates_text()

    def apply_flow_edits(self):
        # parse entries; validate
        newF = [[0.0] * self.n for _ in range(self.n)]
        try:
            for i in range(self.n):
                for j in range(self.n):
                    s = self.flow_vars[i][j].get().strip()
                    if s == '':
                        val = 0.0
                    else:
                        val = float(s)
                    if val < 0:
                        raise ValueError('Flows must be non-negative')
                    newF[i][j] = val
        except Exception as e:
            messagebox.showerror('Invalid flow', f'Check flow values: {e}')
            return

        if self.sym_var.get():
            # force symmetric by averaging
            for i in range(self.n):
                for j in range(i+1, self.n):
                    avg = (newF[i][j] + newF[j][i]) / 2.0
                    newF[i][j] = newF[j][i] = avg

        self.F = newF
        self.update_swap_candidates_text()
        self.status_var.set('Applied flow edits')

    def on_flow_cell_changed(self, i, j):
        # called when a flow cell is edited; mirror to [j][i] if symmetry requested
        if self._updating_mirror:
            return
        try:
            s = self.flow_vars[i][j].get().strip()
            val = 0.0 if s == '' else float(s)
            if val < 0:
                return
        except Exception:
            return
        # update internal F
        self.F[i][j] = val
        if self.sym_var.get():
            try:
                self._updating_mirror = True
                self.flow_vars[j][i].set(str(int(val) if float(val).is_integer() else f'{val:.2f}'))
                self.F[j][i] = val
            finally:
                self._updating_mirror = False
        self.update_swap_candidates_text()

    def on_rows_cols_change(self):
        # applied when user changes rows/cols spinboxes; validate and rebuild positions
        if self._rows_cols_guard:
            return
        try:
            r = int(self.rows_var.get())
            c = int(self.cols_var.get())
        except Exception:
            return
        if r <= 0 or c <= 0:
            self.status_var.set('Invalid grid: Rows and Cols must be positive')
            self._rows_cols_guard = True
            try:
                self.rows_var.set(self._last_valid_rows)
                self.cols_var.set(self._last_valid_cols)
            finally:
                self._rows_cols_guard = False
            return
        if r * c < self.n:
            self.status_var.set('Invalid grid: Rows*Cols must be >= n')
            self._rows_cols_guard = True
            try:
                self.rows_var.set(self._last_valid_rows)
                self.cols_var.set(self._last_valid_cols)
            finally:
                self._rows_cols_guard = False
            return
        self._last_valid_rows = r
        self._last_valid_cols = c
        self.positions, self.grid_rows, self.grid_cols = make_grid_positions(self.n, rows=r, cols=c)
        # recompute D if not custom
        if not getattr(self, 'use_custom_dist_var', tk.BooleanVar()).get():
            self.D = compute_distance_matrix(self.positions, self.metric)
        self.refresh_all()

    # ---------- Visualization ----------
    def refresh_canvas(self):
        self.canvas.delete('all')
        # draw grid based on grid_rows & grid_cols
        w = self.canvas.winfo_width() or 640
        h = self.canvas.winfo_height() or 480
        rows = self.grid_rows
        cols = self.grid_cols
        cell_w = w / max(cols, 1)
        cell_h = h / max(rows, 1)

        # draw cells
        pos_index_to_dept = {self.layout[i]: i for i in range(len(self.layout))}
        self._pos_index_to_dept = pos_index_to_dept

        for p_idx in range(rows * cols):
            r = p_idx // cols
            c = p_idx % cols
            x0 = c * cell_w
            y0 = r * cell_h
            x1 = x0 + cell_w
            y1 = y0 + cell_h
            if p_idx < len(self.positions):
                if p_idx in pos_index_to_dept:
                    dept = pos_index_to_dept[p_idx]
                    fill = '#cfe8ff'
                    outline = 'black'
                    if p_idx in self.highlight_positions:
                        fill = '#ffe4a3'
                        outline = '#d59b2d'
                    self.canvas.create_rectangle(x0+2, y0+2, x1-2, y1-2, fill=fill, outline=outline)
                    self.canvas.create_text((x0 + x1)/2, (y0+y1)/2, text=self.names[dept], font=('Arial', 12, 'bold'))
                    self.canvas.create_text(
                        (x0 + x1) / 2,
                        y1 - 12,
                        text=f'P{p_idx}',
                        font=('Arial', 9),
                        fill='#b0b0b0'
                    )
                else:
                    fill = '#eeeeee'
                    self.canvas.create_rectangle(x0+2, y0+2, x1-2, y1-2, fill=fill, outline='gray')
                    if p_idx < self.n:
                        self.canvas.create_text(
                            (x0 + x1) / 2,
                            (y0 + y1) / 2,
                            text=f'P{p_idx}',
                            font=('Arial', 10, 'italic'),
                            fill='#b0b0b0'
                        )
            else:
                self.canvas.create_rectangle(x0+2, y0+2, x1-2, y1-2, fill='#f9f9f9', outline='gray')

        # show cost
        current_cost = total_cost(self.F, self.D, self.layout)
        self.canvas.create_text(10, 10, anchor='nw', text=f'Cost: {current_cost:.2f}', font=('Arial', 12, 'bold'))

    def _cell_from_xy(self, x, y):
        rows = self.grid_rows
        cols = self.grid_cols
        w = self.canvas.winfo_width() or 640
        h = self.canvas.winfo_height() or 480
        cell_w = w / max(cols, 1)
        cell_h = h / max(rows, 1)
        c = int(x // cell_w)
        r = int(y // cell_h)
        if r < 0 or c < 0 or r >= rows or c >= cols:
            return None
        p_idx = r * cols + c
        if p_idx >= len(self.positions):
            return None
        return p_idx

    def _cell_bounds(self, p_idx):
        rows = self.grid_rows
        cols = self.grid_cols
        w = self.canvas.winfo_width() or 640
        h = self.canvas.winfo_height() or 480
        cell_w = w / max(cols, 1)
        cell_h = h / max(rows, 1)
        r = p_idx // cols
        c = p_idx % cols
        x0 = c * cell_w
        y0 = r * cell_h
        x1 = x0 + cell_w
        y1 = y0 + cell_h
        return x0, y0, x1, y1

    def _draw_drag_outline(self, p_idx, color):
        self.canvas.delete('drag_outline')
        if p_idx is None:
            return
        x0, y0, x1, y1 = self._cell_bounds(p_idx)
        self.canvas.create_rectangle(
            x0 + 3, y0 + 3, x1 - 3, y1 - 3,
            outline=color, width=2, dash=(3, 2),
            tags='drag_outline'
        )

    def _draw_drag_active(self, p_idx):
        self.canvas.delete('drag_active')
        if p_idx is None:
            return
        x0, y0, x1, y1 = self._cell_bounds(p_idx)
        self.canvas.create_rectangle(
            x0 + 2, y0 + 2, x1 - 2, y1 - 2,
            outline='#f08a24', width=3,
            fill='#ffd27f', stipple='gray50',
            tags='drag_active'
        )

    def _schedule_swap_highlight(self, positions):
        self.highlight_positions = set(p for p in positions if p is not None)
        if self.highlight_after_id:
            self.after_cancel(self.highlight_after_id)
            self.highlight_after_id = None
        self.refresh_canvas()
        self.highlight_after_id = self.after(2500, self._clear_swap_highlight)

    def _clear_swap_highlight(self):
        self.highlight_positions = set()
        self.highlight_after_id = None
        self.refresh_canvas()

    def on_canvas_press(self, event):
        p_idx = self._cell_from_xy(event.x, event.y)
        if p_idx is None:
            return
        dept = getattr(self, '_pos_index_to_dept', {}).get(p_idx)
        if dept is None:
            return
        self.drag_active = True
        self.drag_start_pos = p_idx
        self.drag_over_pos = p_idx
        self._draw_drag_active(p_idx)
        self._draw_drag_outline(p_idx, '#5a8edb')
        self.canvas.delete('drag_ghost')
        text_id = self.canvas.create_text(
            event.x, event.y,
            text=self.names[dept],
            font=('Arial', 12, 'bold'),
            fill='#555555',
            tags='drag_ghost'
        )
        bbox = self.canvas.bbox(text_id)
        if bbox:
            x0, y0, x1, y1 = bbox
            pad = 6
            rect_id = self.canvas.create_rectangle(
                x0 - pad, y0 - pad, x1 + pad, y1 + pad,
                fill='#ffe4a3', outline='#d59b2d',
                tags='drag_ghost'
            )
            self.canvas.tag_raise(text_id, rect_id)
        self.status_var.set(f'Dragging {self.names[dept]} from P{p_idx}')

    def on_canvas_drag(self, event):
        if not self.drag_active:
            return
        p_idx = self._cell_from_xy(event.x, event.y)
        # update ghost box + text
        items = self.canvas.find_withtag('drag_ghost')
        if items:
            # text item is expected to be last (raised above box)
            text_id = items[-1]
            self.canvas.coords(text_id, event.x, event.y)
            bbox = self.canvas.bbox(text_id)
            if bbox and len(items) > 1:
                x0, y0, x1, y1 = bbox
                pad = 6
                rect_id = items[0]
                self.canvas.coords(rect_id, x0 - pad, y0 - pad, x1 + pad, y1 + pad)
        if p_idx != self.drag_over_pos:
            self.drag_over_pos = p_idx
            self._draw_drag_outline(p_idx, '#9aa0a6')

    def on_canvas_release(self, event):
        if not self.drag_active:
            return
        target = self._cell_from_xy(event.x, event.y)
        source = self.drag_start_pos
        self.drag_active = False
        self.drag_start_pos = None
        self.drag_over_pos = None
        self.canvas.delete('drag_outline')
        self.canvas.delete('drag_active')
        self.canvas.delete('drag_ghost')
        if target is None or source is None or target == source:
            self.status_var.set('Drop on another occupied cell to swap')
            return
        target_dept = getattr(self, '_pos_index_to_dept', {}).get(target)
        if target_dept is None:
            self.status_var.set('Drop on another occupied cell to swap')
            return
        a = target_dept
        b = getattr(self, '_pos_index_to_dept', {}).get(source)
        if a is None or b is None or a == b:
            return
        self.layout[a], self.layout[b] = self.layout[b], self.layout[a]
        self._refresh_distance_if_computed()
        self.refresh_canvas()
        self.update_swap_candidates_text()
        self._schedule_swap_highlight([source, target])
        self.status_var.set(f'Swapped {self.names[a]} and {self.names[b]}')

    # ---------- Swap candidate listing and selection ----------
    def compute_all_candidate_deltas(self):
        pairs = []
        n = self.n
        for a in range(n):
            for b in range(a+1, n):
                d = delta_cost_for_swap(self.F, self.D, self.layout, a, b)
                # also compute full recompute after hypothetical swap for validation
                # but we will compute that on demand to save time
                pairs.append(((a, b), d))
        pairs.sort(key=lambda x: x[1])  # ascending by delta (more negative better)
        return pairs

    def update_swap_candidates_text(self):
        pairs = self.compute_all_candidate_deltas()
        show_all = self.show_all_var.get()
        topk = max(1, int(self.topk_var.get()))
        self.swap_text.delete('1.0', 'end')
        current_cost = total_cost(self.F, self.D, self.layout)
        self.swap_text.insert('end', f'Current total cost: {current_cost:.2f}\n')
        self.swap_text.insert('end', f'Total candidate swaps: {len(pairs)}\n\n')
        to_show = pairs if show_all else pairs[:topk]
        for (a, b), d in to_show:
            self.swap_text.insert('end', f'Swap {self.names[a]} <-> {self.names[b]} : ΔC = {d:.4f}\n')

        if pairs and pairs[0][1] < -1e-9:
            best = pairs[0]
            self.swap_text.insert('end', '\nBest improving swap: {} <-> {} ΔC={:.4f}\n'.format(self.names[best[0][0]], self.names[best[0][1]], best[1]))
        else:
            self.swap_text.insert('end', '\nNo improving swap exists (local optimum)\n')

    def save_project(self):
        f = filedialog.asksaveasfilename(defaultextension='.json', filetypes=[('JSON files','*.json')])
        if not f:
            return
        data = {
            'n': self.n,
            'rows': self.grid_rows,
            'cols': self.grid_cols,
            'metric': self.metric_var.get(),
            'force_symmetric': self.sym_var.get(),
            'use_custom_distance': self.use_custom_dist_var.get(),
            'force_symmetric_dist': self.sym_dist_var.get(),
            'max_iterations': int(self.max_iter_var.get()),
            'show_all': self.show_all_var.get(),
            'top_k': int(self.topk_var.get()),
            'random': {
                'min_flow': int(self.min_flow_var.get()),
                'max_flow': int(self.max_flow_var.get()),
                'sparsity': float(self.sparsity_var.get()),
                'seed': self.seed_var.get(),
                'min_dist': int(self.min_dist_var.get()),
                'max_dist': int(self.max_dist_var.get()),
                'dist_sparsity': float(self.dist_sparsity_var.get()),
                'dist_seed': self.dist_seed_var.get(),
            },
            'F': self.F,
            'D': self.D,
            'layout': self.layout,
            'history': self.history,
        }
        with open(f, 'w', encoding='utf-8') as fh:
            json.dump(data, fh, indent=2)
        self.status_var.set(f'Saved project to {f}')

    def load_project(self):
        f = filedialog.askopenfilename(filetypes=[('JSON files','*.json')])
        if not f:
            return
        with open(f, 'r', encoding='utf-8') as fh:
            data = json.load(fh)
        self.n = int(data.get('n', self.n))
        self.names = [f'D{i+1}' for i in range(self.n)]
        self.grid_rows = int(data.get('rows', self.grid_rows))
        self.grid_cols = int(data.get('cols', self.grid_cols))
        self.positions, self.grid_rows, self.grid_cols = make_grid_positions(self.n, rows=self.grid_rows, cols=self.grid_cols)
        self.metric_var.set(data.get('metric', self.metric))
        self.sym_var.set(bool(data.get('force_symmetric', self.sym_var.get())))
        self.use_custom_dist_var.set(bool(data.get('use_custom_distance', self.use_custom_dist_var.get())))
        self.sym_dist_var.set(bool(data.get('force_symmetric_dist', self.sym_dist_var.get())))
        self.max_iter_var.set(int(data.get('max_iterations', self.max_iterations)))
        self.show_all_var.set(bool(data.get('show_all', True)))
        self.topk_var.set(int(data.get('top_k', 10)))
        rnd = data.get('random', {})
        self.min_flow_var.set(int(rnd.get('min_flow', self.min_flow_var.get())))
        self.max_flow_var.set(int(rnd.get('max_flow', self.max_flow_var.get())))
        self.sparsity_var.set(float(rnd.get('sparsity', self.sparsity_var.get())))
        self.seed_var.set(rnd.get('seed', self.seed_var.get()))
        self.min_dist_var.set(int(rnd.get('min_dist', self.min_dist_var.get())))
        self.max_dist_var.set(int(rnd.get('max_dist', self.max_dist_var.get())))
        self.dist_sparsity_var.set(float(rnd.get('dist_sparsity', self.dist_sparsity_var.get())))
        self.dist_seed_var.set(rnd.get('dist_seed', self.dist_seed_var.get()))
        self.F = data.get('F', self.F)
        self.layout = data.get('layout', self.layout)
        if self.use_custom_dist_var.get():
            self.D = data.get('D', self.D)
        else:
            self.D = compute_distance_matrix(self.positions, self.metric_var.get())
        self.history = data.get('history', [])
        self.history_index = len(self.history) - 1 if self.history else -1
        self.n_var.set(self.n)
        self.rows_var.set(self.grid_rows)
        self.cols_var.set(self.grid_cols)
        self._last_valid_rows = self.grid_rows
        self._last_valid_cols = self.grid_cols
        self.refresh_all()
        self.status_var.set(f'Loaded project from {f}')

    def show_quick_help(self):
        msg = (
            "Quick Guide\n"
            "1) Set n and (optional) Rows/Cols\n"
            "2) Use Random Generator OR enter your own values in matrices\n"
            "3) Random generation uses your current Rows/Cols if valid\n"
            "4) Apply Flow/Distance Edits after manual changes\n"
            "5) Drag to swap departments or use Next Step\n"
            "6) Run to End to finish\n"
            "Notes:\n"
            "- Rows*Cols must be >= n\n"
            "- Custom Distance ON enables distance editing\n"
        )
        messagebox.showinfo('Quick Guide', msg)

    def _matrix_entry_width(self):
        if self.n >= 11:
            return 4
        if self.n >= 9:
            return 5
        return 6

    def _add_info_button(self, frame, text):
        try:
            bg = frame.cget('background')
        except Exception:
            bg = '#f0f0f0'
        if bg in (None, '', 'SystemButtonFace'):
            bg = self.cget('bg')
        canvas = tk.Canvas(frame, width=18, height=18, highlightthickness=0, bg=bg)
        canvas._tooltip_bg = bg
        canvas.place(relx=1.0, rely=1.0, x=-6, y=-6, anchor='se')
        bubble = canvas.create_oval(2, 2, 16, 16, fill=bg, outline=bg)
        label = canvas.create_text(9, 9, text='i', fill='#9a9a9a', font=('Arial', 8, 'bold'))
        self._attach_tooltip(canvas, text)
        canvas.tag_bind(bubble, '<Enter>', lambda e: self._show_tooltip(canvas, text))
        canvas.tag_bind(bubble, '<Leave>', lambda e: self._hide_tooltip(canvas))
        canvas.tag_bind(label, '<Enter>', lambda e: self._show_tooltip(canvas, text))
        canvas.tag_bind(label, '<Leave>', lambda e: self._hide_tooltip(canvas))
        return canvas

    def _attach_tooltip(self, widget, text):
        widget._tooltip_text = text
        widget._tooltip_win = None
        widget.bind('<Enter>', lambda e: self._show_tooltip(widget, text))
        widget.bind('<Leave>', lambda e: self._hide_tooltip(widget))

    def _show_tooltip(self, widget, text):
        if getattr(widget, '_tooltip_win', None) is not None:
            return
        win = tk.Toplevel(self)
        win.wm_overrideredirect(True)
        win.attributes('-topmost', True)
        bg = getattr(widget, '_tooltip_bg', '#f0f0f0')
        label = tk.Label(win, text=text, bg=bg, relief='solid', borderwidth=1)
        label.pack(ipadx=6, ipady=4)
        x = widget.winfo_rootx() + 10
        y = widget.winfo_rooty() + widget.winfo_height() + 6
        win.wm_geometry(f'+{x}+{y}')
        widget._tooltip_win = win

    def _hide_tooltip(self, widget):
        win = getattr(widget, '_tooltip_win', None)
        if win is not None:
            win.destroy()
            widget._tooltip_win = None

    # ---------- Algorithm steps and control ----------
    def next_step(self):
        # perform a single best swap if exists; record history entry
        pairs = self.compute_all_candidate_deltas()
        if not pairs:
            self.status_var.set('No candidate swaps')
            return
        best_pair, best_delta = pairs[0]
        a, b = best_pair
        if best_delta >= -1e-9:
            self.status_var.set('Local optimum reached; no improving swap')
            return

        old_layout = list(self.layout)
        old_cost = total_cost(self.F, self.D, old_layout)

        # apply swap
        self.layout[a], self.layout[b] = self.layout[b], self.layout[a]
        new_cost = total_cost(self.F, self.D, self.layout)

        # validate delta by recompute
        recompute_delta = new_cost - old_cost
        efficient_delta = best_delta
        ok = abs(recompute_delta - efficient_delta) < 1e-6

        explanation = f"Swapped {self.names[a]} (P{old_layout[a]}) and {self.names[b]} (P{old_layout[b]})."
        if ok:
            explanation += f" ΔC matches: {efficient_delta:.4f}."
        else:
            explanation += f" ΔC mismatch: efficient {efficient_delta:.6f} vs recompute {recompute_delta:.6f}."

        entry = {
            'iteration': len(self.history) + 1,
            'swap': (a, b),
            'delta': efficient_delta,
            'old_cost': old_cost,
            'new_cost': new_cost,
            'layout': list(self.layout),
            'explanation': explanation,
        }
        self.history.append(entry)
        self.history_index = len(self.history) - 1

        self.refresh_canvas()
        self._refresh_distance_if_computed()
        self.update_swap_candidates_text()
        self.status_var.set(f'Applied swap {self.names[a]}<->{self.names[b]} (ΔC={efficient_delta:.4f})')

    def prev_step(self):
        if self.history_index < 0:
            self.status_var.set('No previous step')
            return
        # revert last history step
        idx = self.history_index
        if idx == 0:
            # revert to initial (before any steps)
            # initial layout needs to be stored - we used first history; we'll reconstruct
            # Easiest approach: when history_index==0 revert to initial recorded layout by undoing that swap
            entry = self.history[idx]
            a, b = entry['swap']
            # swap back
            self.layout[a], self.layout[b] = self.layout[b], self.layout[a]
            self.history.pop(idx)
            self.history_index = -1
            self.status_var.set('Reverted to initial layout')
        else:
            # undo last swap by swapping the recorded swap
            entry = self.history.pop()
            a, b = entry['swap']
            self.layout[a], self.layout[b] = self.layout[b], self.layout[a]
            self.history_index = len(self.history) - 1
            self.status_var.set(f'Reverted swap {self.names[a]}<->{self.names[b]}')

        self.refresh_canvas()
        self._refresh_distance_if_computed()
        self.update_swap_candidates_text()

    def reset_to_initial(self):
        # we cannot infer original initial layout if history grew, so store initial when first change made
        # Simpler: if history empty, do nothing. If not empty, reconstruct initial by reversing all history in reverse.
        if not self.history:
            self.status_var.set('Already at initial')
            return
        # revert all swaps by undoing in reverse order
        for entry in reversed(self.history):
            a, b = entry['swap']
            self.layout[a], self.layout[b] = self.layout[b], self.layout[a]
        cnt = len(self.history)
        self.history = []
        self.history_index = -1
        self.refresh_canvas()
        self._refresh_distance_if_computed()
        self.update_swap_candidates_text()
        self.status_var.set(f'Reset to initial (undid {cnt} swaps)')

    def run_to_end(self):
        if self.running:
            # stop
            self.running = False
            if self.run_after_id:
                self.after_cancel(self.run_after_id)
            self.run_after_id = None
            self.status_var.set('Stopped')
            return
        self.running = True
        self.status_var.set('Running to end...')
        self.max_iterations = int(self.max_iter_var.get())
        self.run_loop(0)

    def run_loop(self, iter_count):
        if not self.running:
            return
        if iter_count >= self.max_iterations:
            self.running = False
            self.status_var.set('Max iterations reached')
            return
        # attempt one step
        pairs = self.compute_all_candidate_deltas()
        if not pairs or pairs[0][1] >= -1e-9:
            self.running = False
            self.status_var.set('Finished: local optimum reached')
            return
        self.next_step()
        # schedule next
        self.run_after_id = self.after(200, lambda: self.run_loop(iter_count + 1))

    # ---------- Validation ----------
    def validate_current_delta(self):
        pairs = self.compute_all_candidate_deltas()
        if not pairs:
            messagebox.showinfo('Validate', 'No candidate swaps')
            return
        (a, b), efficient_delta = pairs[0]
        # compute full recompute
        old_layout = list(self.layout)
        old_cost = total_cost(self.F, self.D, old_layout)
        new_layout = list(old_layout)
        new_layout[a], new_layout[b] = new_layout[b], new_layout[a]
        new_cost = total_cost(self.F, self.D, new_layout)
        recompute_delta = new_cost - old_cost
        ok = abs(recompute_delta - efficient_delta) < 1e-6
        msg = f'Best swap {self.names[a]}<->{self.names[b]}\nEfficient ΔC={efficient_delta:.6f}\nRecompute ΔC={recompute_delta:.6f}\nMatch: {ok}'
        messagebox.showinfo('ΔC Validation', msg)

    # ---------- Export ----------
    def export_csv(self):
        if not self.history:
            messagebox.showinfo('Export', 'No history to export')
            return
        f = filedialog.asksaveasfilename(defaultextension='.csv', filetypes=[('CSV files','*.csv')])
        if not f:
            return
        with open(f, 'w', newline='', encoding='utf-8') as fh:
            writer = csv.writer(fh)
            writer.writerow(['iteration', 'swap_a', 'swap_b', 'delta', 'old_cost', 'new_cost', 'layout', 'explanation'])
            for e in self.history:
                a, b = e['swap']
                writer.writerow([e['iteration'], self.names[a], self.names[b], e['delta'], e['old_cost'], e['new_cost'], ';'.join(map(str,e['layout'])), e['explanation']])
        self.status_var.set(f'Exported CSV to {f}')

    def export_txt(self):
        f = filedialog.asksaveasfilename(defaultextension='.txt', filetypes=[('Text files','*.txt')])
        if not f:
            return
        with open(f, 'w', encoding='utf-8') as fh:
            fh.write('Pairwise Exchange Method Report\n')
            fh.write('===============================\n')
            fh.write(f'n = {self.n}\n')
            fh.write(f'Metric = {self.metric_var.get()}\n')
            fh.write('\nInitial layout: (as starting before any recorded swaps)\n')
            # reconstruct initial layout by undoing history on a copy
            if self.history:
                # start from current layout and undo
                cur = list(self.layout)
                # to get initial, undo in reverse history
                for entry in reversed(self.history):
                    a, b = entry['swap']
                    cur[a], cur[b] = cur[b], cur[a]
                initial_layout = cur
            else:
                initial_layout = self.layout
            fh.write(' '.join([f'{self.names[i]}->P{initial_layout[i]}' for i in range(self.n)]) + '\n')
            fh.write('\nFinal layout: \n')
            fh.write(' '.join([f'{self.names[i]}->P{self.layout[i]}' for i in range(self.n)]) + '\n')
            initial_cost = total_cost(self.F, self.D, initial_layout)
            final_cost = total_cost(self.F, self.D, self.layout)
            fh.write(f'Initial cost: {initial_cost:.4f}\n')
            fh.write(f'Final cost: {final_cost:.4f}\n')
            fh.write(f'Number of swaps: {len(self.history)}\n')
            fh.write('\nSteps:\n')
            for e in self.history:
                a, b = e['swap']
                fh.write(f"{e['iteration']}: swap {self.names[a]}<->{self.names[b]}, ΔC={e['delta']:.4f}, old={e['old_cost']:.4f}, new={e['new_cost']:.4f}\n")
        self.status_var.set(f'Exported TXT to {f}')


if __name__ == '__main__':
    app = PairwiseExchangeApp()
    app.mainloop()
